{# Emit the .hpp code for forward declaring a structure type. #}
{% macro forward_declaration_code(type_info) %}
    struct {{type_info.name}};
{% endmacro %}

{# Emit the preprocessor cleanup code for a structure type. #}
{% macro preprocessor_cleanup_code(type_info) %}
{% endmacro %}

{# Emit the .hpp file code for a structure type definition. #}
{% macro hpp_definition_code(type_info) %}
    {% with struct_info = type_info.schema.structure %}
struct {{type_info.name}}
{
    {% for name, info in ordered_object_items(struct_info) %}
        {% if info.doc %}
    {{info.doc | format_comment(width=75) | indent(4)}}
        {% endif %}
    {{info.schema | cpp_type_for_schema(omissible=info["omissible"])}} {{name}};
    {% endfor %}
};

{{type_info.name}}
make_{{type_info.name}}(
    {% for name, info in ordered_object_items(struct_info) %}
    {{info.schema | cpp_type_for_schema(omissible=info["omissible"])}} const& {{name}}
    {{- "," if not loop.last }}
    {%- endfor %});

    {% if generate_tagged_constructors %}

template<class ArgPack>
auto
make_{{type_info.name}}__tagged(ArgPack&& args)
{
    namespace hana = boost::hana;
    {{type_info.name}} x;
        {% for name, info in ordered_object_items(struct_info) %}
    auto maybe_{{name}} =
        hana::find_if(args,
            [ ](auto&& arg)
            {
                return hana::first(arg) == hana::type_c<{{name}}_field_tag>;
            });
            {% if info["omissible"] %}
    x.{{name}} =
        hana::maybe(x.{{name}}, hana::second, maybe_{{name}});
            {% else %}
    static_assert(
        maybe_{{name}} != hana::nothing,
        ":{{name}} is required but missing from {{type_info.name}} construction");
    x.{{name}} =
        std::forward<
            typename std::remove_reference<decltype(hana::second(*maybe_{{name}}))>::type
          >(hana::second(*maybe_{{name}}));
            {% endif %}
        {% endfor %}
    return x;
}

template<class ...Args>
std::enable_if_t<cradle::has_hana_pair<Args...>::value,{{type_info.name}}>
make_{{type_info.name}}(Args ...args)
{
    return make_{{type_info.name}}__tagged(boost::hana::make_tuple(args...));
}

    {% endif %}

template<>
struct type_info_query<{{type_info.name}}>
{
    static void
    get(api_type_info* info);
};

bool
operator==({{type_info.name}} const& a, {{type_info.name}} const& b);

inline bool
operator!=({{type_info.name}} const& a, {{type_info.name}} const& b)
{ return !(a == b); }

bool
operator<({{type_info.name}} const& a, {{type_info.name}} const& b);

inline bool
operator<=({{type_info.name}} const& a, {{type_info.name}} const& b)
{ return !(b < a); }

inline bool
operator>({{type_info.name}} const& a, {{type_info.name}} const& b)
{ return b < a; }

inline bool
operator>=({{type_info.name}} const& a, {{type_info.name}} const& b)
{ return !(a < b); }

std::ostream&
operator<<(std::ostream& stream, {{type_info.name}} const& x);

void
swap({{type_info.name}}& a, {{type_info.name}}& b);

size_t
deep_sizeof({{type_info.name}} const& x);

size_t
hash_value({{type_info.name}} const& x);

void
to_dynamic(cradle::dynamic* v, {{type_info.name}} const& x);

void
from_dynamic({{type_info.name}}* x, cradle::dynamic const& v);

    {% endwith %}
{% endmacro %}

{# Emit the .cpp file code for a structure type definition. #}
{% macro cpp_definition_code(type_info) %}
    {% with struct_info = type_info.schema.structure %}

{{type_info.name}}
make_{{type_info.name}}(
    {% for name, info in ordered_object_items(struct_info) %}
    {{info.schema | cpp_type_for_schema(omissible=info["omissible"])}} const& {{name}}
    {{- "," if not loop.last }}
    {%- endfor %})
{
    {{type_info.name}} x;
    {% for name, info in ordered_object_items(struct_info) %}
    x.{{name}} = {{name}};
    {% endfor %}
    return x;
}

void
type_info_query<{{type_info.name}}>::get(api_type_info* info)
{
    api_named_type_reference ref;
    ref.app = "cradle";
    ref.name = "{{type_info.name}}";
    *info = make_api_type_info_with_named_type(ref);
}

bool
operator==({{type_info.name}} const& a, {{type_info.name}} const& b)
{
    {% if ordered_object_empty(struct_info) %}
    return true;
    {% else %}
    return
        {{ordered_object_keys(struct_info) |
          map_format("a.{0} == b.{0}") |
          join(" &&\n") |
          indent(8)}};
    {% endif %}
}

bool
operator<({{type_info.name}} const& a, {{type_info.name}} const& b)
{
    {% for field in ordered_object_keys(struct_info) %}
    if (a.{{field}} < b.{{field}})
        return true;
    if (b.{{field}} < a.{{field}})
        return false;
    {% endfor %}
    return false;
}

std::ostream&
operator<<(std::ostream& stream, {{type_info.name}} const& x)
{
    return stream << to_dynamic(x);
}

void
swap({{type_info.name}}& a, {{type_info.name}}& b)
{
    using std::swap;
    {% for field in ordered_object_keys(struct_info) %}
    swap(a.{{field}}, b.{{field}});
    {% endfor %}
}

size_t
deep_sizeof({{type_info.name}} const& x)
{
    using cradle::deep_sizeof;
    {% if ordered_object_empty(struct_info) %}
    return 0;
    {% else %}
    return
        {{ordered_object_keys(struct_info) |
          map_format("deep_sizeof(x.{0})") |
          join(" +\n") |
          indent(8)}};
    {% endif %}
}

size_t
hash_value({{type_info.name}} const& x)
{
    {# Start the hash off using a hash of the type name. #}
    size_t hash = {{ type_info.name | string_hash }};
    {% for field in ordered_object_keys(struct_info) %}
    boost::hash_combine(hash, cradle::invoke_hash(x.{{field}}));
    {% endfor %}
    return hash;
}

void
to_dynamic(cradle::dynamic* v, {{type_info.name}} const& x)
{
    cradle::dynamic_map fields;
    {% for field, info in ordered_object_items(struct_info) %}
        {% if info["omissible"] %}
    if (x.{{field}})
    {
        to_dynamic(&fields["{{field}}"], *x.{{field}});
    }
        {% else %}
    to_dynamic(&fields["{{field}}"], x.{{field}});
        {% endif %}
    {% endfor %}
    *v = std::move(fields);
}

void
from_dynamic({{type_info.name}}* x, cradle::dynamic const& v)
{
    {% if not ordered_object_empty(struct_info) %}
    auto const& fields = cradle::cast<cradle::dynamic_map>(v);
        {% for field, info in ordered_object_items(struct_info) %}
            {% if info["omissible"] %}
    {
        cradle::dynamic const* dynamic_field_value;
        if (get_field(&dynamic_field_value, fields, "{{field}}"))
        {
            try
            {
                {{info.schema | cpp_type_for_schema()}} field_value;
                from_dynamic(&field_value, *dynamic_field_value);
                x->{{field}} = cradle::some(field_value);
            }
            catch (boost::exception& e)
            {
                cradle::add_dynamic_path_element(e, "{{field}}");
                throw;
            }
        }
        else
        {
            x->{{field}} = cradle::none;
        }
    }
            {% else %}
    {
        auto const& dynamic_field_value = get_field(fields, "{{field}}");
        try
        {
            from_dynamic(&x->{{field}}, dynamic_field_value);
        }
        catch (boost::exception& e)
        {
            cradle::add_dynamic_path_element(e, "{{field}}");
            throw;
        }
    }
            {% endif %}
        {% endfor %}
    {% endif %}
}
    {% endwith %}
{% endmacro %}
