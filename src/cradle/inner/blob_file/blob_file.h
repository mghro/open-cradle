#ifndef CRADLE_INNER_CORE_BLOB_FILE_H
#define CRADLE_INNER_CORE_BLOB_FILE_H

/*
 * Blob files are memory-mapped files that allow sharing data between
 * processes. They are implemented in terms of Boost's file_mapping and
 * mapped_region objects:
 * - file_mapping operations translate to open() and close(); in particular,
 *   ~file_mapping() will call close().
 * - mapped_region operations translated to mmap() and munmap().
 * - A mapped_region object may outlive the file_mapping from which it was
 *   created.
 */

#include <memory>
#include <string>

#include <boost/interprocess/mapped_region.hpp>

#include <cradle/inner/core/type_definitions.h>
#include <cradle/inner/fs/types.h>

namespace cradle {

// A blob file being generated by the creator of a blob_file_writer object.
// This typically happens on an RPC server, and the server typically need not
// reference the data once generated, or at the latest when all serializations
// have completed. However, unmapping would invalidate data() in the owning
// blob.
class blob_file_writer : public data_owner
{
 public:
    blob_file_writer(file_path path, std::size_t size);

    bool
    maps_file() const override
    {
        return true;
    }

    std::string
    mapped_file() const override
    {
        return path_.string();
    }

    void
    on_write_completed() override;

    std::uint8_t*
    data()
    {
        return data_;
    }

    std::byte*
    bytes()
    {
        return reinterpret_cast<std::byte*>(data_);
    }

    std::size_t
    size() const
    {
        return size_;
    }

 private:
    file_path path_;
    std::size_t size_;
    std::uint8_t* data_;
    boost::interprocess::mapped_region region_;
};

// Read access to a blob file.
class blob_file_reader : public data_owner
{
 public:
    blob_file_reader(file_path path);

    bool
    maps_file() const override
    {
        return true;
    }

    std::string
    mapped_file() const override
    {
        return path_.string();
    }

    std::uint8_t*
    data()
    {
        return data_;
    }

    std::byte*
    bytes()
    {
        return reinterpret_cast<std::byte*>(data_);
    }

    std::size_t
    size() const
    {
        return size_;
    }

 private:
    file_path path_;
    std::size_t size_;
    std::uint8_t* data_;
    boost::interprocess::mapped_region region_;
};

} // namespace cradle

#endif
