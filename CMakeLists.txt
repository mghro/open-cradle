cmake_minimum_required(VERSION 3.14)
project(cradle)

# Define the options for using the preprocessor.
# TODO: Add a Docker option.
set(PREPROCESSOR_USAGE_OPTIONS Native External)
set(PREPROCESSOR_USAGE Native CACHE STRING
    "How the preprocessor should be invoked")
set_property(CACHE PREPROCESSOR_USAGE PROPERTY
    STRINGS ${PREPROCESSOR_USAGE_OPTIONS})
set(EXTERNALLY_PREPROCESSED_DIRECTORY "" CACHE STRING
    "If PREPROCESSOR_USAGE is External, this is the directory that contains the externally preprocessed files.")

# Define the option for local Docker testing.
set(LOCAL_DOCKER_TESTING ON CACHE BOOL
    "Whether or not to enable testing that requires a local Docker instance")
if(LOCAL_DOCKER_TESTING)
    add_compile_options(-DLOCAL_DOCKER_TESTING)
endif()

set(GPROF_PROFILING OFF CACHE BOOL
    "Enable CPU profiling using gprof")

# Detect the compiler.
if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    set(IS_CLANG true)
else()
    set(IS_CLANG false)
endif()
if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    set(IS_GCC true)
else()
    set(IS_GCC false)
endif()
if(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    set(IS_MSVC true)
else()
    set(IS_MSVC false)
endif()

# CRADLE requires C++20
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED TRUE)

# version_info.h defines the CRADLE version.
# It's generated by a custom target, so the command will always run.
add_custom_target(version_info
    COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/version.cmake)

# Download/include CMake/Conan integration.
if(NOT EXISTS "${CMAKE_CURRENT_BINARY_DIR}/conan.cmake")
    message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
    file(DOWNLOAD "https://raw.githubusercontent.com/conan-io/cmake-conan/0.18.1/conan.cmake"
                  "${CMAKE_CURRENT_BINARY_DIR}/conan.cmake"
                  TLS_VERIFY ON)
endif()
include(${CMAKE_CURRENT_BINARY_DIR}/conan.cmake)

# Invoke Conan.
conan_cmake_configure(
    REQUIRES
        boost/1.77.0
        catch2/2.13.4
        nlohmann_json/3.9.1
        msgpack/3.3.0
        libcurl/7.75.0
        openssl/1.1.1j
        sqlite3/3.35.2
        fakeit/2.0.7
        websocketpp/0.8.2
        zlib/1.2.12
        bzip2/1.0.8
        yaml-cpp/0.6.3
        spdlog/1.10.0
        simdjson/0.9.1
        lz4/1.9.3
        fmt/8.1.1
        cereal/1.3.2
        benchmark/1.6.1
        rpclib/2.3.0
    OPTIONS
        boost:without_chrono=True
        boost:without_container=True
        boost:without_context=True
        boost:without_contract=True
        boost:without_coroutine=True
        boost:without_fiber=True
        boost:without_graph=True
        boost:without_graph_parallel=True
        boost:without_iostreams=True
        boost:without_json=True
        boost:without_locale=True
        boost:without_log=True
        boost:without_mpi=True
        boost:without_nowide=True
        boost:without_serialization=True
        boost:without_stacktrace=True
        boost:without_test=True
        boost:without_thread=True
        boost:without_timer=True
        boost:without_type_erasure=True
        boost:without_wave=True
        fakeit:integration=catch
        *:shared=False
    GENERATORS cmake_find_package)

conan_cmake_autodetect(settings)

conan_cmake_install(
    PATH_OR_REFERENCE .
    BUILD missing
    REMOTE conancenter
    SETTINGS ${settings})

include(FetchContent)

# The cppcoro detection logic seems broken for GCC 10.x (at least in CI), so
# override it.
if(IS_GCC OR IS_CLANG)
    add_library(std::coroutines INTERFACE IMPORTED)
    set(CXX_COROUTINES_HAVE_COROUTINES TRUE CACHE BOOL "TRUE if we have the C++ coroutines feature" FORCE)
    set(CXX_COROUTINES_HEADER coroutine CACHE STRING "The header that should be included to obtain the coroutines APIs" FORCE)
    set(CXX_COROUTINES_NAMESPACE std CACHE STRING "The C++ namespace that contains the coroutines APIs" FORCE)
    set(Coroutines_FOUND TRUE CACHE BOOL "TRUE if we can compile and link a program using std::coroutines" FORCE)
if(IS_GCC)
    add_compile_options(-fcoroutines)
endif()
endif()

FetchContent_Declare(fetched_cppcoro
    GIT_REPOSITORY https://github.com/mghro/cppcoro
    GIT_TAG master)
FetchContent_MakeAvailable(fetched_cppcoro)

FetchContent_Declare(fetched_thread_pool
    GIT_REPOSITORY https://github.com/bshoshany/thread-pool
    GIT_TAG v2.0.0)
FetchContent_MakeAvailable(fetched_thread_pool)

list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_BINARY_DIR}")

find_package(Boost REQUIRED COMPONENTS
    filesystem program_options)
find_package(Catch2 REQUIRED)
find_package(nlohmann_json REQUIRED)
find_package(msgpack REQUIRED)
find_package(CURL REQUIRED)
find_package(OpenSSL REQUIRED)
find_package(SQLite3 REQUIRED)
find_package(fakeit REQUIRED)
find_package(websocketpp REQUIRED)
find_package(yaml-cpp REQUIRED)
find_package(spdlog REQUIRED)
find_package(simdjson REQUIRED)
find_package(lz4 REQUIRED)
find_package(cereal REQUIRED)
find_package(benchmark REQUIRED)
find_package(rpclib REQUIRED)

# Add the given linker options on anything that gets linked.
macro(add_link_options )
    string(REPLACE ";" " " OPTIONS "${ARGV}")
    set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} ${OPTIONS}")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${OPTIONS}")
    set(CMAKE_STATIC_LINKER_FLAGS "${CMAKE_STATIC_LINKER_FLAGS} ${OPTIONS}")
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${OPTIONS}")
endmacro()

# Add the given linker options for executables.
macro(add_exe_link_options )
    string(REPLACE ";" " " OPTIONS "${ARGV}")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${OPTIONS}")
endmacro()

# Enable a high level of compiler warnings and treat them as errors.
if(IS_GCC OR IS_CLANG)
    add_compile_options(-Wall -Werror -Wextra -pedantic)
    # Disable warnings that are too strict.
    # unused function parameters
    add_compile_options(-Wno-unused-parameter)
elseif(IS_MSVC)
    # First strip out the old warning level.
    string(REPLACE "/W3" "" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS})
    add_compile_options(/W4 /WX)
    # Disable warnings that are too strict.
    # "unreferenced formal parameter"
    add_compile_options(/wd4100)
    # "declaration hides previous local declaration"
    add_compile_options(/wd4456)
    # "unreferenced local function has been removed"
    add_compile_options(/wd4505)
    # warnings about functions that are potentially insecure
    add_definitions(/D_CRT_SECURE_NO_WARNINGS)
    add_definitions(/D_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
    # Also suppress linker warnings about missing .pdb files that seem to inevitably creep in.
    add_link_options(/ignore:4099)
    # "operator '|': deprecated between enumerations of different types"
    # in cereal\external\rapidjson\document.h
    add_compile_options(/wd5054)
endif()

# Use absolute paths for error messages.
if (IS_CLANG)
    add_compile_options(-fdiagnostics-absolute-paths)
elseif(IS_MSVC)
    add_compile_options(/FC)
endif()
# Full backtrace in error messages.
if(IS_GCC OR IS_CLANG)
    add_compile_options(-ftemplate-backtrace-limit=0)
endif()

# Enable big objects on MSVC.
if(IS_MSVC)
    add_compile_options(/bigobj)
endif()

# Enable the address sanitizer (for now).
# if(IS_MSVC)
#     add_compile_options(/fsanitize=address /Zi)
# endif()

# Exclude as much of the Windows API as possible to avoid #define pollution
# and speed up builds. Note that this has to be done via command-line arguments
# due to the use of precompiled hearders.
if(IS_MSVC)
    add_definitions(/DWIN32_LEAN_AND_MEAN /DVC_EXTRALEAN /DNORASTEROPS /DOEMRESOURCE /DNOATOM /DNOCLIPBOARD /DNOCOLOR /DNOCTRLMGR /DNODRAWTEXT /DNOGDI /DNOKERNEL /DNOMINMAX /DNOSOUND /DNOKANJI /DNOHELP /DNOPROFILER /DNODEFERWINDOWPOS /DNOMCX)
endif()

# Ensure that add_test() has effect.
enable_testing()

if((IS_GCC OR IS_CLANG) AND GPROF_PROFILING)
    message(STATUS "Enabling CPU profiling using gprof")
    add_compile_options(-pg)
    string(APPEND CMAKE_EXE_LINKER_FLAGS " -pg")
elseif(IS_CLANG AND CMAKE_BUILD_TYPE STREQUAL "Debug")
    # Set build options for instrumenting test coverage.
    message(STATUS "Enabling gcov support")
    add_compile_options(-DLLVM_USE_LINKER=gold -fprofile-instr-generate
                        -fcoverage-mapping)
    string(APPEND CMAKE_EXE_LINKER_FLAGS
           " -fprofile-instr-generate -fcoverage-mapping")
endif()

# Preprocess the API headers.
file(GLOB_RECURSE headers CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/*.hpp")
if("${PREPROCESSOR_USAGE}" STREQUAL "Native")
    message(STATUS "Using native preprocessor")
    add_subdirectory(preprocessor)
    set(preprocessed_files ${headers})
    preprocess_header_files(
        generated_srcs generated_headers
        ACCOUNT_ID mgh
        # TODO: Make this its own actual app...
        TYPE_APP_ID dosimetry
        FUNCTION_APP_ID dosimetry
        NAMESPACE cradle
        INDEX_FILE "${CMAKE_CURRENT_BINARY_DIR}/generated/src/cradle/api_index.hpp"
        INPUT_FILES ${preprocessed_files})
    add_custom_target(preprocessing
        DEPENDS ${generated_srcs} ${generated_headers})
    set(generated_src_dirs
        ${CMAKE_CURRENT_BINARY_DIR}/generated/src)
elseif("${PREPROCESSOR_USAGE}" STREQUAL "External")
    message(STATUS "Using externally preprocessed files in:")
    message(STATUS "  ${EXTERNALLY_PREPROCESSED_DIRECTORY}")
    get_filename_component(
        resolved_preprocessed_directory
        "${EXTERNALLY_PREPROCESSED_DIRECTORY}"
        ABSOLUTE)
    message(STATUS "  (${resolved_preprocessed_directory})")
    file(GLOB_RECURSE generated_srcs
        "${resolved_preprocessed_directory}/*.cpp")
    file(GLOB_RECURSE generated_headers
        "${resolved_preprocessed_directory}/*.hpp")
    add_custom_target(preprocessing)
    set(generated_src_dirs
        ${resolved_preprocessed_directory}/src
        ${CMAKE_CURRENT_BINARY_DIR}/generated/src)
else()
    message(FATAL_ERROR "Invalid setting for PREPROCESSOR_USAGE")
endif()

# Files generated by the preprocessor are in ${generated_src_dirs};
# depending on the ${PREPROCESSOR_USAGE} setting, generated by this cmake,
# or provided through other means.
# Other generated files are in ${intgen_src_dir}; always generated by this cmake.
set(intgen_src_dir
    ${CMAKE_CURRENT_BINARY_DIR}/internally_generated/src)

# Set up the deployment directory.
set(deploy_dir "${CMAKE_CURRENT_BINARY_DIR}/deploy")
file(MAKE_DIRECTORY ${deploy_dir})

# Create deploy_dir.h providing access to the deployment directory contents.
set(deploy_dir_file "${intgen_src_dir}/cradle/deploy_dir.h")
add_custom_command(
    OUTPUT ${deploy_dir_file}
    COMMAND ${CMAKE_COMMAND}
        -D input_dir=${CMAKE_CURRENT_SOURCE_DIR}/cmake
        -D output_dir=${intgen_src_dir}/cradle
        -D deploy_dir=${deploy_dir}
        -D compiler_id=${CMAKE_CXX_COMPILER_ID}
        -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/deploy_dir.cmake
    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/cmake/deploy_dir.h.in)

# The library for the in-tree third-party software
file(GLOB_RECURSE srcs_third_party CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/third-party/*.cpp")
add_library(lib_third_party STATIC ${srcs_third_party})
target_compile_definitions(
    lib_third_party PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
target_include_directories(lib_third_party PUBLIC
    src/third-party)

# The library for the inner core
file(GLOB_RECURSE srcs_inner CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/inner/*.cpp")
add_library(cradle_inner STATIC ${srcs_inner})
add_dependencies(cradle_inner version_info)
target_compile_definitions(
    cradle_inner PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
# simdjson.h "local variable is initialized but not referenced"
# Only when building from Visual Studio GUI, not from command line?!
# TODO use recent simdjson
if(IS_MSVC)
    set_property(
        SOURCE src/cradle/inner/service/config_map_json.cpp
        APPEND_STRING PROPERTY COMPILE_FLAGS " /wd4189")
endif()
target_include_directories(cradle_inner PUBLIC
    ${intgen_src_dir}
    src
    src/third-party)
target_link_libraries(cradle_inner PUBLIC
    Boost::headers
    cereal::cereal
    cppcoro
    fmt::fmt
    lz4::lz4
    msgpack::msgpack
    OpenSSL::OpenSSL
    simdjson::simdjson
    spdlog::spdlog)

# A library for the plugins depending on the inner library
file(GLOB_RECURSE srcs_plugins_inner CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/plugins/secondary_cache/local/*.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/plugins/domain/testing/*.cpp")
add_library(cradle_plugins_inner STATIC ${srcs_plugins_inner})
add_dependencies(cradle_plugins_inner preprocessing)
target_compile_definitions(
    cradle_plugins_inner PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
target_include_directories(cradle_plugins_inner PUBLIC
    include
    ${generated_src_dirs}
    src
    src/third-party)
target_link_libraries(cradle_plugins_inner PUBLIC
    cradle_inner
    lib_third_party
    Boost::headers
    cereal::cereal
    cppcoro
    spdlog::spdlog
    SQLite::SQLite3)

# The library for the rpclib client
file(GLOB_RECURSE srcs_rpclib_client CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/rpclib/client/*.cpp")
add_library(cradle_rpclib_client STATIC)
target_sources(cradle_rpclib_client PRIVATE
    ${srcs_rpclib_client}
    ${deploy_dir_file})
target_compile_definitions(
    cradle_rpclib_client PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
target_include_directories(cradle_rpclib_client PRIVATE
    include
    ${intgen_src_dir}
    src)
target_link_libraries(cradle_rpclib_client PUBLIC
    cradle_inner
    Boost::filesystem
    Boost::headers
    cppcoro
    rpclib::rpclib
    spdlog::spdlog)

# The typing library (a.o.) adds a type system (e.g. dynamics)
file(GLOB_RECURSE srcs_typing CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/typing/*.cpp")
add_library(cradle_typing STATIC ${srcs_typing} ${headers})
target_sources(cradle_typing PRIVATE ${generated_headers} ${generated_srcs})
target_compile_definitions(
    cradle_typing PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
target_include_directories(cradle_typing PUBLIC
    include
    ${generated_src_dirs}
    src)
target_link_libraries(cradle_typing PUBLIC
    cradle_inner
    Boost::headers
    Catch2::Catch2
    cppcoro
    CURL::libcurl
    nlohmann_json::nlohmann_json
    spdlog::spdlog
    yaml-cpp::yaml-cpp)

# The library for the plugins depending on the typing library
file(GLOB_RECURSE srcs_plugins_typing CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/plugins/serialization/secondary_cache/legacy/native/*.cpp")
add_library(cradle_plugins_typing STATIC ${srcs_plugins_typing})
add_dependencies(cradle_plugins_typing preprocessing)
target_compile_definitions(
    cradle_plugins_typing PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
target_include_directories(cradle_plugins_typing PUBLIC
    include
    ${generated_src_dirs}
    src)
target_link_libraries(cradle_plugins_typing PUBLIC
    cradle_typing
    cppcoro)

# The thinknode library adds some Thinknode requests
file(GLOB_RECURSE srcs_thinknode CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/thinknode/*.cpp")
add_library(cradle_thinknode STATIC ${srcs_thinknode} ${headers})
target_sources(cradle_thinknode PRIVATE ${generated_headers} ${generated_srcs})
target_compile_definitions(
    cradle_thinknode PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
target_include_directories(cradle_thinknode PUBLIC
    include
    ${generated_src_dirs}
    src
    src/third-party)
target_link_libraries(cradle_thinknode PUBLIC
    cradle_plugins_typing
    cradle_typing
    Boost::headers
    cereal::cereal
    cppcoro
    spdlog::spdlog)

# A library of plugins depending on the thinknode library
file(GLOB_RECURSE srcs_plugins_thinknode CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/plugins/domain/all/*.cpp")
add_library(cradle_plugins_thinknode STATIC ${srcs_plugins_thinknode})
target_compile_definitions(
    cradle_plugins_thinknode PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
target_include_directories(cradle_plugins_thinknode PUBLIC
    ${generated_src_dirs}
    src)
target_link_libraries(cradle_plugins_thinknode PUBLIC
    cradle_thinknode)

# The websocket library adds more Thinknode requests, and a WebSocket interface
file(GLOB_RECURSE srcs_websocket CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/websocket/*.cpp")
add_library(cradle_websocket STATIC ${srcs_websocket} ${headers})
# There doesn't seem to be a better way to disable the warnings that are
# generated by WebSocket++.
if(IS_MSVC)
    set_property(
        SOURCE src/cradle/websocket/server.cpp
        APPEND_STRING PROPERTY COMPILE_FLAGS " /wd4996 /wd4127 /wd4267 /wd4244")
    set_property(
        SOURCE src/cradle/websocket/client.cpp
        APPEND_STRING PROPERTY COMPILE_FLAGS " /wd4996 /wd4127 /wd4267 /wd4244")
endif()
target_sources(cradle_websocket PRIVATE ${generated_headers} ${generated_srcs})
target_compile_definitions(
    cradle_websocket PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
target_include_directories(cradle_websocket PUBLIC
    include
    ${generated_src_dirs}
    src
    src/third-party)
target_link_libraries(cradle_websocket PUBLIC
    cradle_thinknode
    cradle_rpclib_client
    Boost::headers
    cereal::cereal
    cppcoro
    spdlog::spdlog
    websocketpp::websocketpp)

# The external library adds a C++ API
file(GLOB_RECURSE srcs_external CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/external/*.cpp")
add_library(cradle_external STATIC ${srcs_external} ${headers})
target_sources(cradle_external PRIVATE ${generated_headers} ${generated_srcs})
target_compile_definitions(
    cradle_external PUBLIC ${CONAN_DEFINES} ${CONAN_COMPILE_DEFINITIONS})
target_include_directories(cradle_external PUBLIC
    include
    ${generated_src_dirs}
    src)
target_link_libraries(cradle_external PUBLIC
    cradle_websocket)

# The WebSocket server
add_executable(websocket_server src/server.cpp)
target_include_directories(websocket_server PRIVATE
    ${generated_src_dirs}
    src)
target_link_libraries(websocket_server
    cradle_websocket
    cradle_plugins_inner
    Boost::program_options)
add_custom_command(TARGET websocket_server POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:websocket_server> ${deploy_dir})

# The rpclib server
file(GLOB_RECURSE srcs_rpclib_server CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/src/cradle/rpclib/server/*.cpp")
add_executable(rpclib_server ${srcs_rpclib_server})
target_include_directories(rpclib_server PRIVATE
    ${generated_src_dirs}
    src)
target_link_libraries(rpclib_server
    cradle_plugins_thinknode
    cradle_thinknode
    cradle_plugins_inner
    Boost::headers
    Boost::program_options
    cppcoro
    fmt::fmt
    rpclib::rpclib
    spdlog::spdlog)
add_custom_command(TARGET rpclib_server POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:rpclib_server> ${deploy_dir})

# Convenience target denoting all servers
add_custom_target(servers)
add_dependencies(servers websocket_server rpclib_server)

# Retrieve the token info if it exists
if (DEFINED ENV{CRADLE_THINKNODE_API_TOKEN})
    set(API_TOKEN $ENV{CRADLE_THINKNODE_API_TOKEN})
elseif (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/.token")
    file(READ "${CMAKE_CURRENT_SOURCE_DIR}/.token" API_TOKEN)
else()
    message(WARNING "Couldn't find API token.")
    set(API_TOKEN "(missing)")
endif()
string(REGEX REPLACE "\n" "" API_TOKEN "${API_TOKEN}")

# Retrieve the Docker auth info if it exists
if (DEFINED ENV{CRADLE_THINKNODE_DOCKER_AUTH})
    set(DOCKER_AUTH $ENV{CRADLE_THINKNODE_DOCKER_AUTH})
elseif (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/.docker-auth")
    file(READ "${CMAKE_CURRENT_SOURCE_DIR}/.docker-auth" DOCKER_AUTH)
else()
    message(WARNING "Couldn't find Docker auth string.")
    set(DOCKER_AUTH "(missing)")
endif()
string(REGEX REPLACE "\n" "" DOCKER_AUTH "${DOCKER_AUTH}")

add_subdirectory(tests)
add_subdirectory(python)
